from typing import Dict, Any, Optional, List
from pydantic import BaseModel, AnyHttpUrl, ValidationError
from authlib.integrations.starlette_client import OAuth
from starlette.requests import Request as StarletteRequest # For Authlib state generation
from starlette.config import Config as AuthlibConfig # For Authlib client registration
import httpx # For fetching userinfo if needed, and for Authlib client
from sqlalchemy.ext.asyncio import AsyncSession

from warehouse_quote_app.app.core.config import settings
from warehouse_quote_app.app.crud.user_crud import user_crud
from warehouse_quote_app.app.schemas.user import UserCreate # User as UserSchema not used directly
from warehouse_quote_app.app.schemas.auth import Token # Token from app.schemas.user.auth
from warehouse_quote_app.app.services.auth_service import AuthService
from warehouse_quote_app.app.services.crm.base import BaseCRMService # Import BaseCRMService
from warehouse_quote_app.app.schemas.crm import CRMCustomerCreate # Import CRMCustomerCreate
import logging # For logging CRM operations

# For state management, Redis would be good. For now, using a simple in-memory dict for PoC.
# In a real app, this needs to be a persistent and shared store if multiple instances.
# sso_state_store: Dict[str, Dict[str, Any]] = {} # Not used in current simplified state management via Authlib session

logger = logging.getLogger(__name__)


class SSOProviderConfig(BaseModel):
    provider_name: str
    client_id: str
    client_secret: str
    server_metadata_url: Optional[AnyHttpUrl] = None
    issuer: Optional[str] = None # Used if server_metadata_url is not provided
    # Define scopes needed, e.g. openid, email, profile
    client_kwargs: Optional[Dict[str, Any]] = {"scope": "openid email profile"}


class SSOService:
    def __init__(self, auth_service: AuthService, crm_service: BaseCRMService): # Added crm_service
        self.oauth = OAuth()
        self.providers: Dict[str, SSOProviderConfig] = {}
        self.auth_service = auth_service
        self.crm_service = crm_service # Store CRM service instance

        for provider_conf_dict in settings.OIDC_PROVIDERS:
            try:
                config = SSOProviderConfig(**provider_conf_dict)
                self.providers[config.provider_name] = config
                
                client_kwargs = config.client_kwargs or {}
                if 'scope' not in client_kwargs: # Ensure default scope if not provided
                    client_kwargs['scope'] = "openid email profile"

                self.oauth.register(
                    name=config.provider_name,
                    client_id=config.client_id,
                    client_secret=config.client_secret,
                    server_metadata_url=str(config.server_metadata_url) if config.server_metadata_url else None,
                    issuer=config.issuer if not config.server_metadata_url and config.issuer else None, # Authlib might prefer issuer if metadata URL is problematic
                    client_kwargs=client_kwargs,
                )
            except ValidationError as e:
                print(f"Error validating OIDC provider config '{provider_conf_dict.get('provider_name')}': {e}")
            except Exception as e:
                print(f"Error registering OIDC provider '{provider_conf_dict.get('provider_name')}': {e}")


    async def initiate_sso(self, provider_name: str, redirect_uri: str, request: StarletteRequest) -> str:
        """
        Generates the authorization URL for the specified OIDC provider.
        Temporarily stores state for security.
        """
        provider = self.oauth.create_client(provider_name)
        if not provider:
            raise ValueError(f"SSO Provider '{provider_name}' not configured or found.")

        # Store state using StarletteRequest's session or a custom mechanism
        # For this example, using Authlib's built-in state generation via request
        # but managing it manually for clarity and potential Redis integration later.
        
        # `authorize_redirect` generates state and stores it in the session if request.session is available.
        # We need to retrieve that state or generate it manually if not using Starlette sessions directly here.
        # Let's assume request.session is available for Authlib to work seamlessly.
        # If not, one would do: token = await provider.create_authorization_url(redirect_uri)
        # and then extract state from token['state'] and store it.

        # This will generate a URL like:
        # https://provider.example.com/authorize?response_type=code&client_id=CLIENT_ID&redirect_uri=REDIRECT_URI&scope=openid+email+profile&state=STATE_PARAM
        # The 'state' is generated by Authlib and should be stored to verify in callback.
        # The actual state value is typically stored in the user's session by Authlib,
        # or one might need to manage it manually if not using Starlette's session middleware.
        
        # To manually manage state (example, if not using Starlette session middleware here):
        # from authlib.common.security import generate_token
        # state = generate_token()
        # sso_state_store[state] = {"provider": provider_name, "redirect_uri_original": redirect_uri} # Store for verification
        # authorization_url = await provider.create_authorization_url(redirect_uri, state=state)
        # return authorization_url['url']

        # Using Authlib's built-in way with StarletteRequest (requires session middleware)
        # The request object here is a StarletteRequest, which Authlib can use to manage state in session
        res = await provider.authorize_redirect(request, redirect_uri)
        return res.headers['location']


    async def process_sso_callback(
        self, 
        provider_name: str, 
        request: StarletteRequest, # Pass the StarletteRequest for Authlib to get code and state
        db: AsyncSession
    ) -> Token:
        """
        Processes the OIDC callback, exchanges code for token, fetches user info,
        provisions/links user, and returns an application JWT.
        """
        provider = self.oauth.create_client(provider_name)
        if not provider:
            raise ValueError(f"SSO Provider '{provider_name}' not configured or found.")

        try:
            # Exchanges code for token, also verifies state if session is used by Authlib
            # This will also fetch userinfo if 'oidc' is in scope and provider supports it.
            token_data = await provider.authorize_access_token(request)
        except Exception as e:
            # Log error details
            print(f"Error during OIDC token exchange for provider {provider_name}: {e}")
            raise ValueError(f"Failed to process SSO callback with provider {provider_name}. Details: {str(e)}")

        user_info = token_data.get('userinfo')
        if not user_info:
            # Fallback or error if userinfo not in token_data (e.g. if not part of OIDC standard flow for this provider)
            # Some providers might require a separate call to userinfo endpoint using access_token
            # For Authlib, if 'openid profile email' scopes are used, userinfo should be fetched.
            # id_token = token_data.get('id_token') # Parsed id_token claims
            # if id_token: user_info = id_token
            # else: raise ValueError("User information not found in OIDC response.")
            raise ValueError("User information not found in OIDC response.")


        email = user_info.get('email')
        if not email:
            raise ValueError("Email not found in SSO user information.")

        # User Provisioning/Linking & CRM Sync
        db_user = await user_crud.get_user_by_email(db, email=email) # user_crud is async

        if not db_user:
            # Create new user
            name_parts = user_info.get('name', '').split(' ', 1)
            first_name = name_parts[0] if name_parts else user_info.get('given_name','')
            last_name = name_parts[1] if len(name_parts) > 1 else user_info.get('family_name','')
            
            # Ensure UserCreate schema matches available fields
            # UserCreate might have more fields like 'username' if required by your model/AuthService
            new_user_schema = UserCreate(
                email=email,
                password=str(uuid.uuid4()), # Generate a random unusable password
                first_name=first_name,
                last_name=last_name,
                is_active=True, 
                is_verified=True, # Mark as verified via SSO
                # username=email, # If username is required and defaults to email
                # company_name=user_info.get('organization') # If available and needed
            )
            db_user = await self.auth_service.create_user_account(db, user_in=new_user_schema)
            
            # Sync new user to CRM
            crm_customer_data_new = CRMCustomerCreate(
                email=db_user.email,
                first_name=db_user.first_name,
                last_name=db_user.last_name,
                app_user_id=db_user.id
                # phone=db_user.phone, # If available on db_user
                # company_name=db_user.company_name # If available on db_user
            )
            try:
                crm_id = await self.crm_service.create_or_update_customer(customer_data=crm_customer_data_new)
                if crm_id:
                    logger.info(f"New SSO user {db_user.email} (ID: {db_user.id}) synced to CRM with CRM ID: {crm_id}.")
                    # Optionally store crm_id on db_user if model supports it and commit
                else:
                    logger.warning(f"Failed to sync new SSO user {db_user.email} (ID: {db_user.id}) to CRM.")
            except Exception as e:
                logger.error(f"Error syncing new SSO user {db_user.email} to CRM: {e}", exc_info=True)

        elif db_user.is_active:
            # Existing user, sync/update CRM record
            crm_customer_data_existing = CRMCustomerCreate(
                email=db_user.email,
                first_name=db_user.first_name, # Could take from user_info if fresher: user_info.get('given_name', db_user.first_name)
                last_name=db_user.last_name,   # user_info.get('family_name', db_user.last_name)
                app_user_id=db_user.id
                # phone=db_user.phone,
                # company_name=db_user.company_name
            )
            try:
                crm_id = await self.crm_service.create_or_update_customer(customer_data=crm_customer_data_existing)
                if crm_id:
                    logger.info(f"Existing SSO user {db_user.email} (ID: {db_user.id}) data updated/ensured in CRM. CRM ID: {crm_id}.")
                else:
                    logger.warning(f"Failed to update/ensure existing SSO user {db_user.email} (ID: {db_user.id}) in CRM.")
            except Exception as e:
                 logger.error(f"Error updating/ensuring SSO user {db_user.email} in CRM: {e}", exc_info=True)
        else: # User exists but is not active
            raise ValueError("User account is inactive.")
        
        # At this point, db_user is either the existing linked user or the newly created one.
        # Generate application token for this user.
        # AuthService.get_login_token is now async
        app_token = await self.auth_service.get_login_token(db, user_id=db_user.id, email=db_user.email, is_admin=db_user.is_admin)
        return app_token

    async def get_sso_provider_client(self, provider_name: str):
        """Helper to get the Authlib OAuth client."""
        client = self.oauth.create_client(provider_name)
        if not client:
            raise ValueError(f"SSO client for provider '{provider_name}' not found.")
        return client

# Example of how to use this service (conceptual, will be in API endpoints)
# async def example_usage(db: AsyncSession):
#     auth_service = AuthService() # Assuming AuthService can be instantiated like this
#     sso_service = SSOService(auth_service=auth_service)
    
#     # In initiate SSO endpoint:
#     # starlette_request_obj = ... (get from FastAPI)
#     # auth_url = await sso_service.initiate_sso("google", "http://localhost:8000/callback", starlette_request_obj)
#     # return RedirectResponse(auth_url)
    
#     # In callback endpoint:
#     # starlette_request_obj = ... (get from FastAPI, contains code and state)
#     # token_response = await sso_service.process_sso_callback("google", starlette_request_obj, db)
#     # return token_response
